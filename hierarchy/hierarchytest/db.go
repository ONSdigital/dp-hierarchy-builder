// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package hierarchytest

import (
	"context"
	"github.com/ONSdigital/dp-graph/v2/models"
	"sync"
)

// DBMock is a mock implementation of hierarchy.DB.
//
//     func TestSomethingThatUsesDB(t *testing.T) {
//
//         // make and configure a mocked hierarchy.DB
//         mockedDB := &DBMock{
//             CloneNodesFunc: func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
// 	               panic("mock out the CloneNodes method")
//             },
//             CloneNodesFromIDsFunc: func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string, ids map[string]struct{}, hasData bool) error {
// 	               panic("mock out the CloneNodesFromIDs method")
//             },
//             CloneRelationshipsFunc: func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
// 	               panic("mock out the CloneRelationships method")
//             },
//             CloneRelationshipsFromIDsFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string, ids map[string]struct{}) error {
// 	               panic("mock out the CloneRelationshipsFromIDs method")
//             },
//             CountNodesFunc: func(ctx context.Context, instanceID string, dimensionName string) (int64, error) {
// 	               panic("mock out the CountNodes method")
//             },
//             CreateInstanceHierarchyConstraintsFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the CreateInstanceHierarchyConstraints method")
//             },
//             GetCodesWithDataFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) ([]string, error) {
// 	               panic("mock out the GetCodesWithData method")
//             },
//             GetGenericHierarchyAncestriesIDsFunc: func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]struct{}, error) {
// 	               panic("mock out the GetGenericHierarchyAncestriesIDs method")
//             },
//             GetGenericHierarchyNodeIDsFunc: func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]struct{}, error) {
// 	               panic("mock out the GetGenericHierarchyNodeIDs method")
//             },
//             GetHierarchyCodelistFunc: func(ctx context.Context, instanceID string, dimension string) (string, error) {
// 	               panic("mock out the GetHierarchyCodelist method")
//             },
//             GetHierarchyElementFunc: func(ctx context.Context, instanceID string, dimension string, code string) (*models.HierarchyResponse, error) {
// 	               panic("mock out the GetHierarchyElement method")
//             },
//             GetHierarchyNodeIDsFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) (map[string]struct{}, error) {
// 	               panic("mock out the GetHierarchyNodeIDs method")
//             },
//             GetHierarchyRootFunc: func(ctx context.Context, instanceID string, dimension string) (*models.HierarchyResponse, error) {
// 	               panic("mock out the GetHierarchyRoot method")
//             },
//             HierarchyExistsFunc: func(ctx context.Context, instanceID string, dimension string) (bool, error) {
// 	               panic("mock out the HierarchyExists method")
//             },
//             MarkNodesToRemainFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the MarkNodesToRemain method")
//             },
//             RemoveCloneEdgesFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the RemoveCloneEdges method")
//             },
//             RemoveCloneEdgesFromSourceIDsFunc: func(ctx context.Context, attempt int, ids map[string]struct{}) error {
// 	               panic("mock out the RemoveCloneEdgesFromSourceIDs method")
//             },
//             RemoveNodesNotMarkedToRemainFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the RemoveNodesNotMarkedToRemain method")
//             },
//             RemoveRemainMarkerFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the RemoveRemainMarker method")
//             },
//             SetHasDataFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the SetHasData method")
//             },
//             SetNumberOfChildrenFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the SetNumberOfChildren method")
//             },
//             SetNumberOfChildrenFromIDsFunc: func(ctx context.Context, attempt int, ids map[string]struct{}) error {
// 	               panic("mock out the SetNumberOfChildrenFromIDs method")
//             },
//         }
//
//         // use mockedDB in code that requires hierarchy.DB
//         // and then make assertions.
//
//     }
type DBMock struct {
	// CloneNodesFunc mocks the CloneNodes method.
	CloneNodesFunc func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error

	// CloneNodesFromIDsFunc mocks the CloneNodesFromIDs method.
	CloneNodesFromIDsFunc func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string, ids map[string]struct{}, hasData bool) error

	// CloneRelationshipsFunc mocks the CloneRelationships method.
	CloneRelationshipsFunc func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error

	// CloneRelationshipsFromIDsFunc mocks the CloneRelationshipsFromIDs method.
	CloneRelationshipsFromIDsFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string, ids map[string]struct{}) error

	// CountNodesFunc mocks the CountNodes method.
	CountNodesFunc func(ctx context.Context, instanceID string, dimensionName string) (int64, error)

	// CreateInstanceHierarchyConstraintsFunc mocks the CreateInstanceHierarchyConstraints method.
	CreateInstanceHierarchyConstraintsFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// GetCodesWithDataFunc mocks the GetCodesWithData method.
	GetCodesWithDataFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) ([]string, error)

	// GetGenericHierarchyAncestriesIDsFunc mocks the GetGenericHierarchyAncestriesIDs method.
	GetGenericHierarchyAncestriesIDsFunc func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]struct{}, error)

	// GetGenericHierarchyNodeIDsFunc mocks the GetGenericHierarchyNodeIDs method.
	GetGenericHierarchyNodeIDsFunc func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]struct{}, error)

	// GetHierarchyCodelistFunc mocks the GetHierarchyCodelist method.
	GetHierarchyCodelistFunc func(ctx context.Context, instanceID string, dimension string) (string, error)

	// GetHierarchyElementFunc mocks the GetHierarchyElement method.
	GetHierarchyElementFunc func(ctx context.Context, instanceID string, dimension string, code string) (*models.HierarchyResponse, error)

	// GetHierarchyNodeIDsFunc mocks the GetHierarchyNodeIDs method.
	GetHierarchyNodeIDsFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) (map[string]struct{}, error)

	// GetHierarchyRootFunc mocks the GetHierarchyRoot method.
	GetHierarchyRootFunc func(ctx context.Context, instanceID string, dimension string) (*models.HierarchyResponse, error)

	// HierarchyExistsFunc mocks the HierarchyExists method.
	HierarchyExistsFunc func(ctx context.Context, instanceID string, dimension string) (bool, error)

	// MarkNodesToRemainFunc mocks the MarkNodesToRemain method.
	MarkNodesToRemainFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// RemoveCloneEdgesFunc mocks the RemoveCloneEdges method.
	RemoveCloneEdgesFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// RemoveCloneEdgesFromSourceIDsFunc mocks the RemoveCloneEdgesFromSourceIDs method.
	RemoveCloneEdgesFromSourceIDsFunc func(ctx context.Context, attempt int, ids map[string]struct{}) error

	// RemoveNodesNotMarkedToRemainFunc mocks the RemoveNodesNotMarkedToRemain method.
	RemoveNodesNotMarkedToRemainFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// RemoveRemainMarkerFunc mocks the RemoveRemainMarker method.
	RemoveRemainMarkerFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// SetHasDataFunc mocks the SetHasData method.
	SetHasDataFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// SetNumberOfChildrenFunc mocks the SetNumberOfChildren method.
	SetNumberOfChildrenFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// SetNumberOfChildrenFromIDsFunc mocks the SetNumberOfChildrenFromIDs method.
	SetNumberOfChildrenFromIDsFunc func(ctx context.Context, attempt int, ids map[string]struct{}) error

	// calls tracks calls to the methods.
	calls struct {
		// CloneNodes holds details about calls to the CloneNodes method.
		CloneNodes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// CodeListID is the codeListID argument value.
			CodeListID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// CloneNodesFromIDs holds details about calls to the CloneNodesFromIDs method.
		CloneNodesFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// CodeListID is the codeListID argument value.
			CodeListID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
			// Ids is the ids argument value.
			Ids map[string]struct{}
			// HasData is the hasData argument value.
			HasData bool
		}
		// CloneRelationships holds details about calls to the CloneRelationships method.
		CloneRelationships []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// CodeListID is the codeListID argument value.
			CodeListID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// CloneRelationshipsFromIDs holds details about calls to the CloneRelationshipsFromIDs method.
		CloneRelationshipsFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
			// Ids is the ids argument value.
			Ids map[string]struct{}
		}
		// CountNodes holds details about calls to the CountNodes method.
		CountNodes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// CreateInstanceHierarchyConstraints holds details about calls to the CreateInstanceHierarchyConstraints method.
		CreateInstanceHierarchyConstraints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// GetCodesWithData holds details about calls to the GetCodesWithData method.
		GetCodesWithData []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// GetGenericHierarchyAncestriesIDs holds details about calls to the GetGenericHierarchyAncestriesIDs method.
		GetGenericHierarchyAncestriesIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// CodeListID is the codeListID argument value.
			CodeListID string
			// Codes is the codes argument value.
			Codes []string
		}
		// GetGenericHierarchyNodeIDs holds details about calls to the GetGenericHierarchyNodeIDs method.
		GetGenericHierarchyNodeIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// CodeListID is the codeListID argument value.
			CodeListID string
			// Codes is the codes argument value.
			Codes []string
		}
		// GetHierarchyCodelist holds details about calls to the GetHierarchyCodelist method.
		GetHierarchyCodelist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// GetHierarchyElement holds details about calls to the GetHierarchyElement method.
		GetHierarchyElement []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
			// Code is the code argument value.
			Code string
		}
		// GetHierarchyNodeIDs holds details about calls to the GetHierarchyNodeIDs method.
		GetHierarchyNodeIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// GetHierarchyRoot holds details about calls to the GetHierarchyRoot method.
		GetHierarchyRoot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// HierarchyExists holds details about calls to the HierarchyExists method.
		HierarchyExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// MarkNodesToRemain holds details about calls to the MarkNodesToRemain method.
		MarkNodesToRemain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// RemoveCloneEdges holds details about calls to the RemoveCloneEdges method.
		RemoveCloneEdges []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// RemoveCloneEdgesFromSourceIDs holds details about calls to the RemoveCloneEdgesFromSourceIDs method.
		RemoveCloneEdgesFromSourceIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// Ids is the ids argument value.
			Ids map[string]struct{}
		}
		// RemoveNodesNotMarkedToRemain holds details about calls to the RemoveNodesNotMarkedToRemain method.
		RemoveNodesNotMarkedToRemain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// RemoveRemainMarker holds details about calls to the RemoveRemainMarker method.
		RemoveRemainMarker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// SetHasData holds details about calls to the SetHasData method.
		SetHasData []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// SetNumberOfChildren holds details about calls to the SetNumberOfChildren method.
		SetNumberOfChildren []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// SetNumberOfChildrenFromIDs holds details about calls to the SetNumberOfChildrenFromIDs method.
		SetNumberOfChildrenFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// Ids is the ids argument value.
			Ids map[string]struct{}
		}
	}
	lockCloneNodes                         sync.RWMutex
	lockCloneNodesFromIDs                  sync.RWMutex
	lockCloneRelationships                 sync.RWMutex
	lockCloneRelationshipsFromIDs          sync.RWMutex
	lockCountNodes                         sync.RWMutex
	lockCreateInstanceHierarchyConstraints sync.RWMutex
	lockGetCodesWithData                   sync.RWMutex
	lockGetGenericHierarchyAncestriesIDs   sync.RWMutex
	lockGetGenericHierarchyNodeIDs         sync.RWMutex
	lockGetHierarchyCodelist               sync.RWMutex
	lockGetHierarchyElement                sync.RWMutex
	lockGetHierarchyNodeIDs                sync.RWMutex
	lockGetHierarchyRoot                   sync.RWMutex
	lockHierarchyExists                    sync.RWMutex
	lockMarkNodesToRemain                  sync.RWMutex
	lockRemoveCloneEdges                   sync.RWMutex
	lockRemoveCloneEdgesFromSourceIDs      sync.RWMutex
	lockRemoveNodesNotMarkedToRemain       sync.RWMutex
	lockRemoveRemainMarker                 sync.RWMutex
	lockSetHasData                         sync.RWMutex
	lockSetNumberOfChildren                sync.RWMutex
	lockSetNumberOfChildrenFromIDs         sync.RWMutex
}

// CloneNodes calls CloneNodesFunc.
func (mock *DBMock) CloneNodes(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
	if mock.CloneNodesFunc == nil {
		panic("DBMock.CloneNodesFunc: method is nil but DB.CloneNodes was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		CodeListID:    codeListID,
		DimensionName: dimensionName,
	}
	mock.lockCloneNodes.Lock()
	mock.calls.CloneNodes = append(mock.calls.CloneNodes, callInfo)
	mock.lockCloneNodes.Unlock()
	return mock.CloneNodesFunc(ctx, attempt, instanceID, codeListID, dimensionName)
}

// CloneNodesCalls gets all the calls that were made to CloneNodes.
// Check the length with:
//     len(mockedDB.CloneNodesCalls())
func (mock *DBMock) CloneNodesCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	CodeListID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}
	mock.lockCloneNodes.RLock()
	calls = mock.calls.CloneNodes
	mock.lockCloneNodes.RUnlock()
	return calls
}

// CloneNodesFromIDs calls CloneNodesFromIDsFunc.
func (mock *DBMock) CloneNodesFromIDs(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string, ids map[string]struct{}, hasData bool) error {
	if mock.CloneNodesFromIDsFunc == nil {
		panic("DBMock.CloneNodesFromIDsFunc: method is nil but DB.CloneNodesFromIDs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
		Ids           map[string]struct{}
		HasData       bool
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		CodeListID:    codeListID,
		DimensionName: dimensionName,
		Ids:           ids,
		HasData:       hasData,
	}
	mock.lockCloneNodesFromIDs.Lock()
	mock.calls.CloneNodesFromIDs = append(mock.calls.CloneNodesFromIDs, callInfo)
	mock.lockCloneNodesFromIDs.Unlock()
	return mock.CloneNodesFromIDsFunc(ctx, attempt, instanceID, codeListID, dimensionName, ids, hasData)
}

// CloneNodesFromIDsCalls gets all the calls that were made to CloneNodesFromIDs.
// Check the length with:
//     len(mockedDB.CloneNodesFromIDsCalls())
func (mock *DBMock) CloneNodesFromIDsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	CodeListID    string
	DimensionName string
	Ids           map[string]struct{}
	HasData       bool
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
		Ids           map[string]struct{}
		HasData       bool
	}
	mock.lockCloneNodesFromIDs.RLock()
	calls = mock.calls.CloneNodesFromIDs
	mock.lockCloneNodesFromIDs.RUnlock()
	return calls
}

// CloneRelationships calls CloneRelationshipsFunc.
func (mock *DBMock) CloneRelationships(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
	if mock.CloneRelationshipsFunc == nil {
		panic("DBMock.CloneRelationshipsFunc: method is nil but DB.CloneRelationships was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		CodeListID:    codeListID,
		DimensionName: dimensionName,
	}
	mock.lockCloneRelationships.Lock()
	mock.calls.CloneRelationships = append(mock.calls.CloneRelationships, callInfo)
	mock.lockCloneRelationships.Unlock()
	return mock.CloneRelationshipsFunc(ctx, attempt, instanceID, codeListID, dimensionName)
}

// CloneRelationshipsCalls gets all the calls that were made to CloneRelationships.
// Check the length with:
//     len(mockedDB.CloneRelationshipsCalls())
func (mock *DBMock) CloneRelationshipsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	CodeListID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}
	mock.lockCloneRelationships.RLock()
	calls = mock.calls.CloneRelationships
	mock.lockCloneRelationships.RUnlock()
	return calls
}

// CloneRelationshipsFromIDs calls CloneRelationshipsFromIDsFunc.
func (mock *DBMock) CloneRelationshipsFromIDs(ctx context.Context, attempt int, instanceID string, dimensionName string, ids map[string]struct{}) error {
	if mock.CloneRelationshipsFromIDsFunc == nil {
		panic("DBMock.CloneRelationshipsFromIDsFunc: method is nil but DB.CloneRelationshipsFromIDs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
		Ids           map[string]struct{}
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
		Ids:           ids,
	}
	mock.lockCloneRelationshipsFromIDs.Lock()
	mock.calls.CloneRelationshipsFromIDs = append(mock.calls.CloneRelationshipsFromIDs, callInfo)
	mock.lockCloneRelationshipsFromIDs.Unlock()
	return mock.CloneRelationshipsFromIDsFunc(ctx, attempt, instanceID, dimensionName, ids)
}

// CloneRelationshipsFromIDsCalls gets all the calls that were made to CloneRelationshipsFromIDs.
// Check the length with:
//     len(mockedDB.CloneRelationshipsFromIDsCalls())
func (mock *DBMock) CloneRelationshipsFromIDsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
	Ids           map[string]struct{}
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
		Ids           map[string]struct{}
	}
	mock.lockCloneRelationshipsFromIDs.RLock()
	calls = mock.calls.CloneRelationshipsFromIDs
	mock.lockCloneRelationshipsFromIDs.RUnlock()
	return calls
}

// CountNodes calls CountNodesFunc.
func (mock *DBMock) CountNodes(ctx context.Context, instanceID string, dimensionName string) (int64, error) {
	if mock.CountNodesFunc == nil {
		panic("DBMock.CountNodesFunc: method is nil but DB.CountNodes was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockCountNodes.Lock()
	mock.calls.CountNodes = append(mock.calls.CountNodes, callInfo)
	mock.lockCountNodes.Unlock()
	return mock.CountNodesFunc(ctx, instanceID, dimensionName)
}

// CountNodesCalls gets all the calls that were made to CountNodes.
// Check the length with:
//     len(mockedDB.CountNodesCalls())
func (mock *DBMock) CountNodesCalls() []struct {
	Ctx           context.Context
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		InstanceID    string
		DimensionName string
	}
	mock.lockCountNodes.RLock()
	calls = mock.calls.CountNodes
	mock.lockCountNodes.RUnlock()
	return calls
}

// CreateInstanceHierarchyConstraints calls CreateInstanceHierarchyConstraintsFunc.
func (mock *DBMock) CreateInstanceHierarchyConstraints(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.CreateInstanceHierarchyConstraintsFunc == nil {
		panic("DBMock.CreateInstanceHierarchyConstraintsFunc: method is nil but DB.CreateInstanceHierarchyConstraints was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockCreateInstanceHierarchyConstraints.Lock()
	mock.calls.CreateInstanceHierarchyConstraints = append(mock.calls.CreateInstanceHierarchyConstraints, callInfo)
	mock.lockCreateInstanceHierarchyConstraints.Unlock()
	return mock.CreateInstanceHierarchyConstraintsFunc(ctx, attempt, instanceID, dimensionName)
}

// CreateInstanceHierarchyConstraintsCalls gets all the calls that were made to CreateInstanceHierarchyConstraints.
// Check the length with:
//     len(mockedDB.CreateInstanceHierarchyConstraintsCalls())
func (mock *DBMock) CreateInstanceHierarchyConstraintsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockCreateInstanceHierarchyConstraints.RLock()
	calls = mock.calls.CreateInstanceHierarchyConstraints
	mock.lockCreateInstanceHierarchyConstraints.RUnlock()
	return calls
}

// GetCodesWithData calls GetCodesWithDataFunc.
func (mock *DBMock) GetCodesWithData(ctx context.Context, attempt int, instanceID string, dimensionName string) ([]string, error) {
	if mock.GetCodesWithDataFunc == nil {
		panic("DBMock.GetCodesWithDataFunc: method is nil but DB.GetCodesWithData was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockGetCodesWithData.Lock()
	mock.calls.GetCodesWithData = append(mock.calls.GetCodesWithData, callInfo)
	mock.lockGetCodesWithData.Unlock()
	return mock.GetCodesWithDataFunc(ctx, attempt, instanceID, dimensionName)
}

// GetCodesWithDataCalls gets all the calls that were made to GetCodesWithData.
// Check the length with:
//     len(mockedDB.GetCodesWithDataCalls())
func (mock *DBMock) GetCodesWithDataCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockGetCodesWithData.RLock()
	calls = mock.calls.GetCodesWithData
	mock.lockGetCodesWithData.RUnlock()
	return calls
}

// GetGenericHierarchyAncestriesIDs calls GetGenericHierarchyAncestriesIDsFunc.
func (mock *DBMock) GetGenericHierarchyAncestriesIDs(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]struct{}, error) {
	if mock.GetGenericHierarchyAncestriesIDsFunc == nil {
		panic("DBMock.GetGenericHierarchyAncestriesIDsFunc: method is nil but DB.GetGenericHierarchyAncestriesIDs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}{
		Ctx:        ctx,
		Attempt:    attempt,
		CodeListID: codeListID,
		Codes:      codes,
	}
	mock.lockGetGenericHierarchyAncestriesIDs.Lock()
	mock.calls.GetGenericHierarchyAncestriesIDs = append(mock.calls.GetGenericHierarchyAncestriesIDs, callInfo)
	mock.lockGetGenericHierarchyAncestriesIDs.Unlock()
	return mock.GetGenericHierarchyAncestriesIDsFunc(ctx, attempt, codeListID, codes)
}

// GetGenericHierarchyAncestriesIDsCalls gets all the calls that were made to GetGenericHierarchyAncestriesIDs.
// Check the length with:
//     len(mockedDB.GetGenericHierarchyAncestriesIDsCalls())
func (mock *DBMock) GetGenericHierarchyAncestriesIDsCalls() []struct {
	Ctx        context.Context
	Attempt    int
	CodeListID string
	Codes      []string
} {
	var calls []struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}
	mock.lockGetGenericHierarchyAncestriesIDs.RLock()
	calls = mock.calls.GetGenericHierarchyAncestriesIDs
	mock.lockGetGenericHierarchyAncestriesIDs.RUnlock()
	return calls
}

// GetGenericHierarchyNodeIDs calls GetGenericHierarchyNodeIDsFunc.
func (mock *DBMock) GetGenericHierarchyNodeIDs(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]struct{}, error) {
	if mock.GetGenericHierarchyNodeIDsFunc == nil {
		panic("DBMock.GetGenericHierarchyNodeIDsFunc: method is nil but DB.GetGenericHierarchyNodeIDs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}{
		Ctx:        ctx,
		Attempt:    attempt,
		CodeListID: codeListID,
		Codes:      codes,
	}
	mock.lockGetGenericHierarchyNodeIDs.Lock()
	mock.calls.GetGenericHierarchyNodeIDs = append(mock.calls.GetGenericHierarchyNodeIDs, callInfo)
	mock.lockGetGenericHierarchyNodeIDs.Unlock()
	return mock.GetGenericHierarchyNodeIDsFunc(ctx, attempt, codeListID, codes)
}

// GetGenericHierarchyNodeIDsCalls gets all the calls that were made to GetGenericHierarchyNodeIDs.
// Check the length with:
//     len(mockedDB.GetGenericHierarchyNodeIDsCalls())
func (mock *DBMock) GetGenericHierarchyNodeIDsCalls() []struct {
	Ctx        context.Context
	Attempt    int
	CodeListID string
	Codes      []string
} {
	var calls []struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}
	mock.lockGetGenericHierarchyNodeIDs.RLock()
	calls = mock.calls.GetGenericHierarchyNodeIDs
	mock.lockGetGenericHierarchyNodeIDs.RUnlock()
	return calls
}

// GetHierarchyCodelist calls GetHierarchyCodelistFunc.
func (mock *DBMock) GetHierarchyCodelist(ctx context.Context, instanceID string, dimension string) (string, error) {
	if mock.GetHierarchyCodelistFunc == nil {
		panic("DBMock.GetHierarchyCodelistFunc: method is nil but DB.GetHierarchyCodelist was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	mock.lockGetHierarchyCodelist.Lock()
	mock.calls.GetHierarchyCodelist = append(mock.calls.GetHierarchyCodelist, callInfo)
	mock.lockGetHierarchyCodelist.Unlock()
	return mock.GetHierarchyCodelistFunc(ctx, instanceID, dimension)
}

// GetHierarchyCodelistCalls gets all the calls that were made to GetHierarchyCodelist.
// Check the length with:
//     len(mockedDB.GetHierarchyCodelistCalls())
func (mock *DBMock) GetHierarchyCodelistCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}
	mock.lockGetHierarchyCodelist.RLock()
	calls = mock.calls.GetHierarchyCodelist
	mock.lockGetHierarchyCodelist.RUnlock()
	return calls
}

// GetHierarchyElement calls GetHierarchyElementFunc.
func (mock *DBMock) GetHierarchyElement(ctx context.Context, instanceID string, dimension string, code string) (*models.HierarchyResponse, error) {
	if mock.GetHierarchyElementFunc == nil {
		panic("DBMock.GetHierarchyElementFunc: method is nil but DB.GetHierarchyElement was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
		Code       string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
		Code:       code,
	}
	mock.lockGetHierarchyElement.Lock()
	mock.calls.GetHierarchyElement = append(mock.calls.GetHierarchyElement, callInfo)
	mock.lockGetHierarchyElement.Unlock()
	return mock.GetHierarchyElementFunc(ctx, instanceID, dimension, code)
}

// GetHierarchyElementCalls gets all the calls that were made to GetHierarchyElement.
// Check the length with:
//     len(mockedDB.GetHierarchyElementCalls())
func (mock *DBMock) GetHierarchyElementCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
	Code       string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
		Code       string
	}
	mock.lockGetHierarchyElement.RLock()
	calls = mock.calls.GetHierarchyElement
	mock.lockGetHierarchyElement.RUnlock()
	return calls
}

// GetHierarchyNodeIDs calls GetHierarchyNodeIDsFunc.
func (mock *DBMock) GetHierarchyNodeIDs(ctx context.Context, attempt int, instanceID string, dimensionName string) (map[string]struct{}, error) {
	if mock.GetHierarchyNodeIDsFunc == nil {
		panic("DBMock.GetHierarchyNodeIDsFunc: method is nil but DB.GetHierarchyNodeIDs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockGetHierarchyNodeIDs.Lock()
	mock.calls.GetHierarchyNodeIDs = append(mock.calls.GetHierarchyNodeIDs, callInfo)
	mock.lockGetHierarchyNodeIDs.Unlock()
	return mock.GetHierarchyNodeIDsFunc(ctx, attempt, instanceID, dimensionName)
}

// GetHierarchyNodeIDsCalls gets all the calls that were made to GetHierarchyNodeIDs.
// Check the length with:
//     len(mockedDB.GetHierarchyNodeIDsCalls())
func (mock *DBMock) GetHierarchyNodeIDsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockGetHierarchyNodeIDs.RLock()
	calls = mock.calls.GetHierarchyNodeIDs
	mock.lockGetHierarchyNodeIDs.RUnlock()
	return calls
}

// GetHierarchyRoot calls GetHierarchyRootFunc.
func (mock *DBMock) GetHierarchyRoot(ctx context.Context, instanceID string, dimension string) (*models.HierarchyResponse, error) {
	if mock.GetHierarchyRootFunc == nil {
		panic("DBMock.GetHierarchyRootFunc: method is nil but DB.GetHierarchyRoot was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	mock.lockGetHierarchyRoot.Lock()
	mock.calls.GetHierarchyRoot = append(mock.calls.GetHierarchyRoot, callInfo)
	mock.lockGetHierarchyRoot.Unlock()
	return mock.GetHierarchyRootFunc(ctx, instanceID, dimension)
}

// GetHierarchyRootCalls gets all the calls that were made to GetHierarchyRoot.
// Check the length with:
//     len(mockedDB.GetHierarchyRootCalls())
func (mock *DBMock) GetHierarchyRootCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}
	mock.lockGetHierarchyRoot.RLock()
	calls = mock.calls.GetHierarchyRoot
	mock.lockGetHierarchyRoot.RUnlock()
	return calls
}

// HierarchyExists calls HierarchyExistsFunc.
func (mock *DBMock) HierarchyExists(ctx context.Context, instanceID string, dimension string) (bool, error) {
	if mock.HierarchyExistsFunc == nil {
		panic("DBMock.HierarchyExistsFunc: method is nil but DB.HierarchyExists was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	mock.lockHierarchyExists.Lock()
	mock.calls.HierarchyExists = append(mock.calls.HierarchyExists, callInfo)
	mock.lockHierarchyExists.Unlock()
	return mock.HierarchyExistsFunc(ctx, instanceID, dimension)
}

// HierarchyExistsCalls gets all the calls that were made to HierarchyExists.
// Check the length with:
//     len(mockedDB.HierarchyExistsCalls())
func (mock *DBMock) HierarchyExistsCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}
	mock.lockHierarchyExists.RLock()
	calls = mock.calls.HierarchyExists
	mock.lockHierarchyExists.RUnlock()
	return calls
}

// MarkNodesToRemain calls MarkNodesToRemainFunc.
func (mock *DBMock) MarkNodesToRemain(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.MarkNodesToRemainFunc == nil {
		panic("DBMock.MarkNodesToRemainFunc: method is nil but DB.MarkNodesToRemain was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockMarkNodesToRemain.Lock()
	mock.calls.MarkNodesToRemain = append(mock.calls.MarkNodesToRemain, callInfo)
	mock.lockMarkNodesToRemain.Unlock()
	return mock.MarkNodesToRemainFunc(ctx, attempt, instanceID, dimensionName)
}

// MarkNodesToRemainCalls gets all the calls that were made to MarkNodesToRemain.
// Check the length with:
//     len(mockedDB.MarkNodesToRemainCalls())
func (mock *DBMock) MarkNodesToRemainCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockMarkNodesToRemain.RLock()
	calls = mock.calls.MarkNodesToRemain
	mock.lockMarkNodesToRemain.RUnlock()
	return calls
}

// RemoveCloneEdges calls RemoveCloneEdgesFunc.
func (mock *DBMock) RemoveCloneEdges(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.RemoveCloneEdgesFunc == nil {
		panic("DBMock.RemoveCloneEdgesFunc: method is nil but DB.RemoveCloneEdges was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockRemoveCloneEdges.Lock()
	mock.calls.RemoveCloneEdges = append(mock.calls.RemoveCloneEdges, callInfo)
	mock.lockRemoveCloneEdges.Unlock()
	return mock.RemoveCloneEdgesFunc(ctx, attempt, instanceID, dimensionName)
}

// RemoveCloneEdgesCalls gets all the calls that were made to RemoveCloneEdges.
// Check the length with:
//     len(mockedDB.RemoveCloneEdgesCalls())
func (mock *DBMock) RemoveCloneEdgesCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockRemoveCloneEdges.RLock()
	calls = mock.calls.RemoveCloneEdges
	mock.lockRemoveCloneEdges.RUnlock()
	return calls
}

// RemoveCloneEdgesFromSourceIDs calls RemoveCloneEdgesFromSourceIDsFunc.
func (mock *DBMock) RemoveCloneEdgesFromSourceIDs(ctx context.Context, attempt int, ids map[string]struct{}) error {
	if mock.RemoveCloneEdgesFromSourceIDsFunc == nil {
		panic("DBMock.RemoveCloneEdgesFromSourceIDsFunc: method is nil but DB.RemoveCloneEdgesFromSourceIDs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]struct{}
	}{
		Ctx:     ctx,
		Attempt: attempt,
		Ids:     ids,
	}
	mock.lockRemoveCloneEdgesFromSourceIDs.Lock()
	mock.calls.RemoveCloneEdgesFromSourceIDs = append(mock.calls.RemoveCloneEdgesFromSourceIDs, callInfo)
	mock.lockRemoveCloneEdgesFromSourceIDs.Unlock()
	return mock.RemoveCloneEdgesFromSourceIDsFunc(ctx, attempt, ids)
}

// RemoveCloneEdgesFromSourceIDsCalls gets all the calls that were made to RemoveCloneEdgesFromSourceIDs.
// Check the length with:
//     len(mockedDB.RemoveCloneEdgesFromSourceIDsCalls())
func (mock *DBMock) RemoveCloneEdgesFromSourceIDsCalls() []struct {
	Ctx     context.Context
	Attempt int
	Ids     map[string]struct{}
} {
	var calls []struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]struct{}
	}
	mock.lockRemoveCloneEdgesFromSourceIDs.RLock()
	calls = mock.calls.RemoveCloneEdgesFromSourceIDs
	mock.lockRemoveCloneEdgesFromSourceIDs.RUnlock()
	return calls
}

// RemoveNodesNotMarkedToRemain calls RemoveNodesNotMarkedToRemainFunc.
func (mock *DBMock) RemoveNodesNotMarkedToRemain(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.RemoveNodesNotMarkedToRemainFunc == nil {
		panic("DBMock.RemoveNodesNotMarkedToRemainFunc: method is nil but DB.RemoveNodesNotMarkedToRemain was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockRemoveNodesNotMarkedToRemain.Lock()
	mock.calls.RemoveNodesNotMarkedToRemain = append(mock.calls.RemoveNodesNotMarkedToRemain, callInfo)
	mock.lockRemoveNodesNotMarkedToRemain.Unlock()
	return mock.RemoveNodesNotMarkedToRemainFunc(ctx, attempt, instanceID, dimensionName)
}

// RemoveNodesNotMarkedToRemainCalls gets all the calls that were made to RemoveNodesNotMarkedToRemain.
// Check the length with:
//     len(mockedDB.RemoveNodesNotMarkedToRemainCalls())
func (mock *DBMock) RemoveNodesNotMarkedToRemainCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockRemoveNodesNotMarkedToRemain.RLock()
	calls = mock.calls.RemoveNodesNotMarkedToRemain
	mock.lockRemoveNodesNotMarkedToRemain.RUnlock()
	return calls
}

// RemoveRemainMarker calls RemoveRemainMarkerFunc.
func (mock *DBMock) RemoveRemainMarker(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.RemoveRemainMarkerFunc == nil {
		panic("DBMock.RemoveRemainMarkerFunc: method is nil but DB.RemoveRemainMarker was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockRemoveRemainMarker.Lock()
	mock.calls.RemoveRemainMarker = append(mock.calls.RemoveRemainMarker, callInfo)
	mock.lockRemoveRemainMarker.Unlock()
	return mock.RemoveRemainMarkerFunc(ctx, attempt, instanceID, dimensionName)
}

// RemoveRemainMarkerCalls gets all the calls that were made to RemoveRemainMarker.
// Check the length with:
//     len(mockedDB.RemoveRemainMarkerCalls())
func (mock *DBMock) RemoveRemainMarkerCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockRemoveRemainMarker.RLock()
	calls = mock.calls.RemoveRemainMarker
	mock.lockRemoveRemainMarker.RUnlock()
	return calls
}

// SetHasData calls SetHasDataFunc.
func (mock *DBMock) SetHasData(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.SetHasDataFunc == nil {
		panic("DBMock.SetHasDataFunc: method is nil but DB.SetHasData was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockSetHasData.Lock()
	mock.calls.SetHasData = append(mock.calls.SetHasData, callInfo)
	mock.lockSetHasData.Unlock()
	return mock.SetHasDataFunc(ctx, attempt, instanceID, dimensionName)
}

// SetHasDataCalls gets all the calls that were made to SetHasData.
// Check the length with:
//     len(mockedDB.SetHasDataCalls())
func (mock *DBMock) SetHasDataCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockSetHasData.RLock()
	calls = mock.calls.SetHasData
	mock.lockSetHasData.RUnlock()
	return calls
}

// SetNumberOfChildren calls SetNumberOfChildrenFunc.
func (mock *DBMock) SetNumberOfChildren(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.SetNumberOfChildrenFunc == nil {
		panic("DBMock.SetNumberOfChildrenFunc: method is nil but DB.SetNumberOfChildren was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	mock.lockSetNumberOfChildren.Lock()
	mock.calls.SetNumberOfChildren = append(mock.calls.SetNumberOfChildren, callInfo)
	mock.lockSetNumberOfChildren.Unlock()
	return mock.SetNumberOfChildrenFunc(ctx, attempt, instanceID, dimensionName)
}

// SetNumberOfChildrenCalls gets all the calls that were made to SetNumberOfChildren.
// Check the length with:
//     len(mockedDB.SetNumberOfChildrenCalls())
func (mock *DBMock) SetNumberOfChildrenCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	mock.lockSetNumberOfChildren.RLock()
	calls = mock.calls.SetNumberOfChildren
	mock.lockSetNumberOfChildren.RUnlock()
	return calls
}

// SetNumberOfChildrenFromIDs calls SetNumberOfChildrenFromIDsFunc.
func (mock *DBMock) SetNumberOfChildrenFromIDs(ctx context.Context, attempt int, ids map[string]struct{}) error {
	if mock.SetNumberOfChildrenFromIDsFunc == nil {
		panic("DBMock.SetNumberOfChildrenFromIDsFunc: method is nil but DB.SetNumberOfChildrenFromIDs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]struct{}
	}{
		Ctx:     ctx,
		Attempt: attempt,
		Ids:     ids,
	}
	mock.lockSetNumberOfChildrenFromIDs.Lock()
	mock.calls.SetNumberOfChildrenFromIDs = append(mock.calls.SetNumberOfChildrenFromIDs, callInfo)
	mock.lockSetNumberOfChildrenFromIDs.Unlock()
	return mock.SetNumberOfChildrenFromIDsFunc(ctx, attempt, ids)
}

// SetNumberOfChildrenFromIDsCalls gets all the calls that were made to SetNumberOfChildrenFromIDs.
// Check the length with:
//     len(mockedDB.SetNumberOfChildrenFromIDsCalls())
func (mock *DBMock) SetNumberOfChildrenFromIDsCalls() []struct {
	Ctx     context.Context
	Attempt int
	Ids     map[string]struct{}
} {
	var calls []struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]struct{}
	}
	mock.lockSetNumberOfChildrenFromIDs.RLock()
	calls = mock.calls.SetNumberOfChildrenFromIDs
	mock.lockSetNumberOfChildrenFromIDs.RUnlock()
	return calls
}
