// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package hierarchytest

import (
	"context"
	"github.com/ONSdigital/dp-graph/v2/models"
	"github.com/ONSdigital/dp-hierarchy-builder/hierarchy"
	"sync"
)

var (
	lockDBMockCloneNodes                         sync.RWMutex
	lockDBMockCloneNodesFromIDs                  sync.RWMutex
	lockDBMockCloneOrderFromIDs                  sync.RWMutex
	lockDBMockCloneRelationships                 sync.RWMutex
	lockDBMockCloneRelationshipsFromIDs          sync.RWMutex
	lockDBMockCountNodes                         sync.RWMutex
	lockDBMockCreateHasCodeEdges                 sync.RWMutex
	lockDBMockCreateInstanceHierarchyConstraints sync.RWMutex
	lockDBMockGetCodesWithData                   sync.RWMutex
	lockDBMockGetGenericHierarchyAncestriesIDs   sync.RWMutex
	lockDBMockGetGenericHierarchyNodeIDs         sync.RWMutex
	lockDBMockGetHierarchyCodelist               sync.RWMutex
	lockDBMockGetHierarchyElement                sync.RWMutex
	lockDBMockGetHierarchyNodeIDs                sync.RWMutex
	lockDBMockGetHierarchyRoot                   sync.RWMutex
	lockDBMockHierarchyExists                    sync.RWMutex
	lockDBMockMarkNodesToRemain                  sync.RWMutex
	lockDBMockRemoveCloneEdges                   sync.RWMutex
	lockDBMockRemoveCloneEdgesFromSourceIDs      sync.RWMutex
	lockDBMockRemoveNodesNotMarkedToRemain       sync.RWMutex
	lockDBMockRemoveRemainMarker                 sync.RWMutex
	lockDBMockSetHasData                         sync.RWMutex
	lockDBMockSetNumberOfChildren                sync.RWMutex
	lockDBMockSetNumberOfChildrenFromIDs         sync.RWMutex
)

// Ensure, that DBMock does implement hierarchy.DB.
// If this is not the case, regenerate this file with moq.
var _ hierarchy.DB = &DBMock{}

// DBMock is a mock implementation of hierarchy.DB.
//
//     func TestSomethingThatUsesDB(t *testing.T) {
//
//         // make and configure a mocked hierarchy.DB
//         mockedDB := &DBMock{
//             CloneNodesFunc: func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
// 	               panic("mock out the CloneNodes method")
//             },
//             CloneNodesFromIDsFunc: func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string, ids map[string]string, hasData bool) error {
// 	               panic("mock out the CloneNodesFromIDs method")
//             },
//             CloneOrderFromIDsFunc: func(ctx context.Context, codeListID string, ids map[string]string) error {
// 	               panic("mock out the CloneOrderFromIDs method")
//             },
//             CloneRelationshipsFunc: func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
// 	               panic("mock out the CloneRelationships method")
//             },
//             CloneRelationshipsFromIDsFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string, ids map[string]string) error {
// 	               panic("mock out the CloneRelationshipsFromIDs method")
//             },
//             CountNodesFunc: func(ctx context.Context, instanceID string, dimensionName string) (int64, error) {
// 	               panic("mock out the CountNodes method")
//             },
//             CreateHasCodeEdgesFunc: func(ctx context.Context, attempt int, codeListID string, codesById map[string]string) error {
// 	               panic("mock out the CreateHasCodeEdges method")
//             },
//             CreateInstanceHierarchyConstraintsFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the CreateInstanceHierarchyConstraints method")
//             },
//             GetCodesWithDataFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) ([]string, error) {
// 	               panic("mock out the GetCodesWithData method")
//             },
//             GetGenericHierarchyAncestriesIDsFunc: func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]string, error) {
// 	               panic("mock out the GetGenericHierarchyAncestriesIDs method")
//             },
//             GetGenericHierarchyNodeIDsFunc: func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]string, error) {
// 	               panic("mock out the GetGenericHierarchyNodeIDs method")
//             },
//             GetHierarchyCodelistFunc: func(ctx context.Context, instanceID string, dimension string) (string, error) {
// 	               panic("mock out the GetHierarchyCodelist method")
//             },
//             GetHierarchyElementFunc: func(ctx context.Context, instanceID string, dimension string, code string) (*models.HierarchyResponse, error) {
// 	               panic("mock out the GetHierarchyElement method")
//             },
//             GetHierarchyNodeIDsFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) (map[string]string, error) {
// 	               panic("mock out the GetHierarchyNodeIDs method")
//             },
//             GetHierarchyRootFunc: func(ctx context.Context, instanceID string, dimension string) (*models.HierarchyResponse, error) {
// 	               panic("mock out the GetHierarchyRoot method")
//             },
//             HierarchyExistsFunc: func(ctx context.Context, instanceID string, dimension string) (bool, error) {
// 	               panic("mock out the HierarchyExists method")
//             },
//             MarkNodesToRemainFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the MarkNodesToRemain method")
//             },
//             RemoveCloneEdgesFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the RemoveCloneEdges method")
//             },
//             RemoveCloneEdgesFromSourceIDsFunc: func(ctx context.Context, attempt int, ids map[string]string) error {
// 	               panic("mock out the RemoveCloneEdgesFromSourceIDs method")
//             },
//             RemoveNodesNotMarkedToRemainFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the RemoveNodesNotMarkedToRemain method")
//             },
//             RemoveRemainMarkerFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the RemoveRemainMarker method")
//             },
//             SetHasDataFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the SetHasData method")
//             },
//             SetNumberOfChildrenFunc: func(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
// 	               panic("mock out the SetNumberOfChildren method")
//             },
//             SetNumberOfChildrenFromIDsFunc: func(ctx context.Context, attempt int, ids map[string]string) error {
// 	               panic("mock out the SetNumberOfChildrenFromIDs method")
//             },
//         }
//
//         // use mockedDB in code that requires hierarchy.DB
//         // and then make assertions.
//
//     }
type DBMock struct {
	// CloneNodesFunc mocks the CloneNodes method.
	CloneNodesFunc func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error

	// CloneNodesFromIDsFunc mocks the CloneNodesFromIDs method.
	CloneNodesFromIDsFunc func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string, ids map[string]string, hasData bool) error

	// CloneOrderFromIDsFunc mocks the CloneOrderFromIDs method.
	CloneOrderFromIDsFunc func(ctx context.Context, codeListID string, ids map[string]string) error

	// CloneRelationshipsFunc mocks the CloneRelationships method.
	CloneRelationshipsFunc func(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error

	// CloneRelationshipsFromIDsFunc mocks the CloneRelationshipsFromIDs method.
	CloneRelationshipsFromIDsFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string, ids map[string]string) error

	// CountNodesFunc mocks the CountNodes method.
	CountNodesFunc func(ctx context.Context, instanceID string, dimensionName string) (int64, error)

	// CreateHasCodeEdgesFunc mocks the CreateHasCodeEdges method.
	CreateHasCodeEdgesFunc func(ctx context.Context, attempt int, codeListID string, codesById map[string]string) error

	// CreateInstanceHierarchyConstraintsFunc mocks the CreateInstanceHierarchyConstraints method.
	CreateInstanceHierarchyConstraintsFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// GetCodesWithDataFunc mocks the GetCodesWithData method.
	GetCodesWithDataFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) ([]string, error)

	// GetGenericHierarchyAncestriesIDsFunc mocks the GetGenericHierarchyAncestriesIDs method.
	GetGenericHierarchyAncestriesIDsFunc func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]string, error)

	// GetGenericHierarchyNodeIDsFunc mocks the GetGenericHierarchyNodeIDs method.
	GetGenericHierarchyNodeIDsFunc func(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]string, error)

	// GetHierarchyCodelistFunc mocks the GetHierarchyCodelist method.
	GetHierarchyCodelistFunc func(ctx context.Context, instanceID string, dimension string) (string, error)

	// GetHierarchyElementFunc mocks the GetHierarchyElement method.
	GetHierarchyElementFunc func(ctx context.Context, instanceID string, dimension string, code string) (*models.HierarchyResponse, error)

	// GetHierarchyNodeIDsFunc mocks the GetHierarchyNodeIDs method.
	GetHierarchyNodeIDsFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) (map[string]string, error)

	// GetHierarchyRootFunc mocks the GetHierarchyRoot method.
	GetHierarchyRootFunc func(ctx context.Context, instanceID string, dimension string) (*models.HierarchyResponse, error)

	// HierarchyExistsFunc mocks the HierarchyExists method.
	HierarchyExistsFunc func(ctx context.Context, instanceID string, dimension string) (bool, error)

	// MarkNodesToRemainFunc mocks the MarkNodesToRemain method.
	MarkNodesToRemainFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// RemoveCloneEdgesFunc mocks the RemoveCloneEdges method.
	RemoveCloneEdgesFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// RemoveCloneEdgesFromSourceIDsFunc mocks the RemoveCloneEdgesFromSourceIDs method.
	RemoveCloneEdgesFromSourceIDsFunc func(ctx context.Context, attempt int, ids map[string]string) error

	// RemoveNodesNotMarkedToRemainFunc mocks the RemoveNodesNotMarkedToRemain method.
	RemoveNodesNotMarkedToRemainFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// RemoveRemainMarkerFunc mocks the RemoveRemainMarker method.
	RemoveRemainMarkerFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// SetHasDataFunc mocks the SetHasData method.
	SetHasDataFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// SetNumberOfChildrenFunc mocks the SetNumberOfChildren method.
	SetNumberOfChildrenFunc func(ctx context.Context, attempt int, instanceID string, dimensionName string) error

	// SetNumberOfChildrenFromIDsFunc mocks the SetNumberOfChildrenFromIDs method.
	SetNumberOfChildrenFromIDsFunc func(ctx context.Context, attempt int, ids map[string]string) error

	// calls tracks calls to the methods.
	calls struct {
		// CloneNodes holds details about calls to the CloneNodes method.
		CloneNodes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// CodeListID is the codeListID argument value.
			CodeListID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// CloneNodesFromIDs holds details about calls to the CloneNodesFromIDs method.
		CloneNodesFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// CodeListID is the codeListID argument value.
			CodeListID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
			// Ids is the ids argument value.
			Ids map[string]string
			// HasData is the hasData argument value.
			HasData bool
		}
		// CloneOrderFromIDs holds details about calls to the CloneOrderFromIDs method.
		CloneOrderFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CodeListID is the codeListID argument value.
			CodeListID string
			// Ids is the ids argument value.
			Ids map[string]string
		}
		// CloneRelationships holds details about calls to the CloneRelationships method.
		CloneRelationships []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// CodeListID is the codeListID argument value.
			CodeListID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// CloneRelationshipsFromIDs holds details about calls to the CloneRelationshipsFromIDs method.
		CloneRelationshipsFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
			// Ids is the ids argument value.
			Ids map[string]string
		}
		// CountNodes holds details about calls to the CountNodes method.
		CountNodes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// CreateHasCodeEdges holds details about calls to the CreateHasCodeEdges method.
		CreateHasCodeEdges []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// CodeListID is the codeListID argument value.
			CodeListID string
			// CodesById is the codesById argument value.
			CodesById map[string]string
		}
		// CreateInstanceHierarchyConstraints holds details about calls to the CreateInstanceHierarchyConstraints method.
		CreateInstanceHierarchyConstraints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// GetCodesWithData holds details about calls to the GetCodesWithData method.
		GetCodesWithData []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// GetGenericHierarchyAncestriesIDs holds details about calls to the GetGenericHierarchyAncestriesIDs method.
		GetGenericHierarchyAncestriesIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// CodeListID is the codeListID argument value.
			CodeListID string
			// Codes is the codes argument value.
			Codes []string
		}
		// GetGenericHierarchyNodeIDs holds details about calls to the GetGenericHierarchyNodeIDs method.
		GetGenericHierarchyNodeIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// CodeListID is the codeListID argument value.
			CodeListID string
			// Codes is the codes argument value.
			Codes []string
		}
		// GetHierarchyCodelist holds details about calls to the GetHierarchyCodelist method.
		GetHierarchyCodelist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// GetHierarchyElement holds details about calls to the GetHierarchyElement method.
		GetHierarchyElement []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
			// Code is the code argument value.
			Code string
		}
		// GetHierarchyNodeIDs holds details about calls to the GetHierarchyNodeIDs method.
		GetHierarchyNodeIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// GetHierarchyRoot holds details about calls to the GetHierarchyRoot method.
		GetHierarchyRoot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// HierarchyExists holds details about calls to the HierarchyExists method.
		HierarchyExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// MarkNodesToRemain holds details about calls to the MarkNodesToRemain method.
		MarkNodesToRemain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// RemoveCloneEdges holds details about calls to the RemoveCloneEdges method.
		RemoveCloneEdges []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// RemoveCloneEdgesFromSourceIDs holds details about calls to the RemoveCloneEdgesFromSourceIDs method.
		RemoveCloneEdgesFromSourceIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// Ids is the ids argument value.
			Ids map[string]string
		}
		// RemoveNodesNotMarkedToRemain holds details about calls to the RemoveNodesNotMarkedToRemain method.
		RemoveNodesNotMarkedToRemain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// RemoveRemainMarker holds details about calls to the RemoveRemainMarker method.
		RemoveRemainMarker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// SetHasData holds details about calls to the SetHasData method.
		SetHasData []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// SetNumberOfChildren holds details about calls to the SetNumberOfChildren method.
		SetNumberOfChildren []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DimensionName is the dimensionName argument value.
			DimensionName string
		}
		// SetNumberOfChildrenFromIDs holds details about calls to the SetNumberOfChildrenFromIDs method.
		SetNumberOfChildrenFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Attempt is the attempt argument value.
			Attempt int
			// Ids is the ids argument value.
			Ids map[string]string
		}
	}
}

// CloneNodes calls CloneNodesFunc.
func (mock *DBMock) CloneNodes(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
	if mock.CloneNodesFunc == nil {
		panic("DBMock.CloneNodesFunc: method is nil but DB.CloneNodes was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		CodeListID:    codeListID,
		DimensionName: dimensionName,
	}
	lockDBMockCloneNodes.Lock()
	mock.calls.CloneNodes = append(mock.calls.CloneNodes, callInfo)
	lockDBMockCloneNodes.Unlock()
	return mock.CloneNodesFunc(ctx, attempt, instanceID, codeListID, dimensionName)
}

// CloneNodesCalls gets all the calls that were made to CloneNodes.
// Check the length with:
//     len(mockedDB.CloneNodesCalls())
func (mock *DBMock) CloneNodesCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	CodeListID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}
	lockDBMockCloneNodes.RLock()
	calls = mock.calls.CloneNodes
	lockDBMockCloneNodes.RUnlock()
	return calls
}

// CloneNodesFromIDs calls CloneNodesFromIDsFunc.
func (mock *DBMock) CloneNodesFromIDs(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string, ids map[string]string, hasData bool) error {
	if mock.CloneNodesFromIDsFunc == nil {
		panic("DBMock.CloneNodesFromIDsFunc: method is nil but DB.CloneNodesFromIDs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
		Ids           map[string]string
		HasData       bool
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		CodeListID:    codeListID,
		DimensionName: dimensionName,
		Ids:           ids,
		HasData:       hasData,
	}
	lockDBMockCloneNodesFromIDs.Lock()
	mock.calls.CloneNodesFromIDs = append(mock.calls.CloneNodesFromIDs, callInfo)
	lockDBMockCloneNodesFromIDs.Unlock()
	return mock.CloneNodesFromIDsFunc(ctx, attempt, instanceID, codeListID, dimensionName, ids, hasData)
}

// CloneNodesFromIDsCalls gets all the calls that were made to CloneNodesFromIDs.
// Check the length with:
//     len(mockedDB.CloneNodesFromIDsCalls())
func (mock *DBMock) CloneNodesFromIDsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	CodeListID    string
	DimensionName string
	Ids           map[string]string
	HasData       bool
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
		Ids           map[string]string
		HasData       bool
	}
	lockDBMockCloneNodesFromIDs.RLock()
	calls = mock.calls.CloneNodesFromIDs
	lockDBMockCloneNodesFromIDs.RUnlock()
	return calls
}

// CloneOrderFromIDs calls CloneOrderFromIDsFunc.
func (mock *DBMock) CloneOrderFromIDs(ctx context.Context, codeListID string, ids map[string]string) error {
	if mock.CloneOrderFromIDsFunc == nil {
		panic("DBMock.CloneOrderFromIDsFunc: method is nil but DB.CloneOrderFromIDs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		CodeListID string
		Ids        map[string]string
	}{
		Ctx:        ctx,
		CodeListID: codeListID,
		Ids:        ids,
	}
	lockDBMockCloneOrderFromIDs.Lock()
	mock.calls.CloneOrderFromIDs = append(mock.calls.CloneOrderFromIDs, callInfo)
	lockDBMockCloneOrderFromIDs.Unlock()
	return mock.CloneOrderFromIDsFunc(ctx, codeListID, ids)
}

// CloneOrderFromIDsCalls gets all the calls that were made to CloneOrderFromIDs.
// Check the length with:
//     len(mockedDB.CloneOrderFromIDsCalls())
func (mock *DBMock) CloneOrderFromIDsCalls() []struct {
	Ctx        context.Context
	CodeListID string
	Ids        map[string]string
} {
	var calls []struct {
		Ctx        context.Context
		CodeListID string
		Ids        map[string]string
	}
	lockDBMockCloneOrderFromIDs.RLock()
	calls = mock.calls.CloneOrderFromIDs
	lockDBMockCloneOrderFromIDs.RUnlock()
	return calls
}

// CloneRelationships calls CloneRelationshipsFunc.
func (mock *DBMock) CloneRelationships(ctx context.Context, attempt int, instanceID string, codeListID string, dimensionName string) error {
	if mock.CloneRelationshipsFunc == nil {
		panic("DBMock.CloneRelationshipsFunc: method is nil but DB.CloneRelationships was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		CodeListID:    codeListID,
		DimensionName: dimensionName,
	}
	lockDBMockCloneRelationships.Lock()
	mock.calls.CloneRelationships = append(mock.calls.CloneRelationships, callInfo)
	lockDBMockCloneRelationships.Unlock()
	return mock.CloneRelationshipsFunc(ctx, attempt, instanceID, codeListID, dimensionName)
}

// CloneRelationshipsCalls gets all the calls that were made to CloneRelationships.
// Check the length with:
//     len(mockedDB.CloneRelationshipsCalls())
func (mock *DBMock) CloneRelationshipsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	CodeListID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		CodeListID    string
		DimensionName string
	}
	lockDBMockCloneRelationships.RLock()
	calls = mock.calls.CloneRelationships
	lockDBMockCloneRelationships.RUnlock()
	return calls
}

// CloneRelationshipsFromIDs calls CloneRelationshipsFromIDsFunc.
func (mock *DBMock) CloneRelationshipsFromIDs(ctx context.Context, attempt int, instanceID string, dimensionName string, ids map[string]string) error {
	if mock.CloneRelationshipsFromIDsFunc == nil {
		panic("DBMock.CloneRelationshipsFromIDsFunc: method is nil but DB.CloneRelationshipsFromIDs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
		Ids           map[string]string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
		Ids:           ids,
	}
	lockDBMockCloneRelationshipsFromIDs.Lock()
	mock.calls.CloneRelationshipsFromIDs = append(mock.calls.CloneRelationshipsFromIDs, callInfo)
	lockDBMockCloneRelationshipsFromIDs.Unlock()
	return mock.CloneRelationshipsFromIDsFunc(ctx, attempt, instanceID, dimensionName, ids)
}

// CloneRelationshipsFromIDsCalls gets all the calls that were made to CloneRelationshipsFromIDs.
// Check the length with:
//     len(mockedDB.CloneRelationshipsFromIDsCalls())
func (mock *DBMock) CloneRelationshipsFromIDsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
	Ids           map[string]string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
		Ids           map[string]string
	}
	lockDBMockCloneRelationshipsFromIDs.RLock()
	calls = mock.calls.CloneRelationshipsFromIDs
	lockDBMockCloneRelationshipsFromIDs.RUnlock()
	return calls
}

// CountNodes calls CountNodesFunc.
func (mock *DBMock) CountNodes(ctx context.Context, instanceID string, dimensionName string) (int64, error) {
	if mock.CountNodesFunc == nil {
		panic("DBMock.CountNodesFunc: method is nil but DB.CountNodes was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockCountNodes.Lock()
	mock.calls.CountNodes = append(mock.calls.CountNodes, callInfo)
	lockDBMockCountNodes.Unlock()
	return mock.CountNodesFunc(ctx, instanceID, dimensionName)
}

// CountNodesCalls gets all the calls that were made to CountNodes.
// Check the length with:
//     len(mockedDB.CountNodesCalls())
func (mock *DBMock) CountNodesCalls() []struct {
	Ctx           context.Context
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		InstanceID    string
		DimensionName string
	}
	lockDBMockCountNodes.RLock()
	calls = mock.calls.CountNodes
	lockDBMockCountNodes.RUnlock()
	return calls
}

// CreateHasCodeEdges calls CreateHasCodeEdgesFunc.
func (mock *DBMock) CreateHasCodeEdges(ctx context.Context, attempt int, codeListID string, codesById map[string]string) error {
	if mock.CreateHasCodeEdgesFunc == nil {
		panic("DBMock.CreateHasCodeEdgesFunc: method is nil but DB.CreateHasCodeEdges was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		CodesById  map[string]string
	}{
		Ctx:        ctx,
		Attempt:    attempt,
		CodeListID: codeListID,
		CodesById:  codesById,
	}
	lockDBMockCreateHasCodeEdges.Lock()
	mock.calls.CreateHasCodeEdges = append(mock.calls.CreateHasCodeEdges, callInfo)
	lockDBMockCreateHasCodeEdges.Unlock()
	return mock.CreateHasCodeEdgesFunc(ctx, attempt, codeListID, codesById)
}

// CreateHasCodeEdgesCalls gets all the calls that were made to CreateHasCodeEdges.
// Check the length with:
//     len(mockedDB.CreateHasCodeEdgesCalls())
func (mock *DBMock) CreateHasCodeEdgesCalls() []struct {
	Ctx        context.Context
	Attempt    int
	CodeListID string
	CodesById  map[string]string
} {
	var calls []struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		CodesById  map[string]string
	}
	lockDBMockCreateHasCodeEdges.RLock()
	calls = mock.calls.CreateHasCodeEdges
	lockDBMockCreateHasCodeEdges.RUnlock()
	return calls
}

// CreateInstanceHierarchyConstraints calls CreateInstanceHierarchyConstraintsFunc.
func (mock *DBMock) CreateInstanceHierarchyConstraints(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.CreateInstanceHierarchyConstraintsFunc == nil {
		panic("DBMock.CreateInstanceHierarchyConstraintsFunc: method is nil but DB.CreateInstanceHierarchyConstraints was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockCreateInstanceHierarchyConstraints.Lock()
	mock.calls.CreateInstanceHierarchyConstraints = append(mock.calls.CreateInstanceHierarchyConstraints, callInfo)
	lockDBMockCreateInstanceHierarchyConstraints.Unlock()
	return mock.CreateInstanceHierarchyConstraintsFunc(ctx, attempt, instanceID, dimensionName)
}

// CreateInstanceHierarchyConstraintsCalls gets all the calls that were made to CreateInstanceHierarchyConstraints.
// Check the length with:
//     len(mockedDB.CreateInstanceHierarchyConstraintsCalls())
func (mock *DBMock) CreateInstanceHierarchyConstraintsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockCreateInstanceHierarchyConstraints.RLock()
	calls = mock.calls.CreateInstanceHierarchyConstraints
	lockDBMockCreateInstanceHierarchyConstraints.RUnlock()
	return calls
}

// GetCodesWithData calls GetCodesWithDataFunc.
func (mock *DBMock) GetCodesWithData(ctx context.Context, attempt int, instanceID string, dimensionName string) ([]string, error) {
	if mock.GetCodesWithDataFunc == nil {
		panic("DBMock.GetCodesWithDataFunc: method is nil but DB.GetCodesWithData was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockGetCodesWithData.Lock()
	mock.calls.GetCodesWithData = append(mock.calls.GetCodesWithData, callInfo)
	lockDBMockGetCodesWithData.Unlock()
	return mock.GetCodesWithDataFunc(ctx, attempt, instanceID, dimensionName)
}

// GetCodesWithDataCalls gets all the calls that were made to GetCodesWithData.
// Check the length with:
//     len(mockedDB.GetCodesWithDataCalls())
func (mock *DBMock) GetCodesWithDataCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockGetCodesWithData.RLock()
	calls = mock.calls.GetCodesWithData
	lockDBMockGetCodesWithData.RUnlock()
	return calls
}

// GetGenericHierarchyAncestriesIDs calls GetGenericHierarchyAncestriesIDsFunc.
func (mock *DBMock) GetGenericHierarchyAncestriesIDs(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]string, error) {
	if mock.GetGenericHierarchyAncestriesIDsFunc == nil {
		panic("DBMock.GetGenericHierarchyAncestriesIDsFunc: method is nil but DB.GetGenericHierarchyAncestriesIDs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}{
		Ctx:        ctx,
		Attempt:    attempt,
		CodeListID: codeListID,
		Codes:      codes,
	}
	lockDBMockGetGenericHierarchyAncestriesIDs.Lock()
	mock.calls.GetGenericHierarchyAncestriesIDs = append(mock.calls.GetGenericHierarchyAncestriesIDs, callInfo)
	lockDBMockGetGenericHierarchyAncestriesIDs.Unlock()
	return mock.GetGenericHierarchyAncestriesIDsFunc(ctx, attempt, codeListID, codes)
}

// GetGenericHierarchyAncestriesIDsCalls gets all the calls that were made to GetGenericHierarchyAncestriesIDs.
// Check the length with:
//     len(mockedDB.GetGenericHierarchyAncestriesIDsCalls())
func (mock *DBMock) GetGenericHierarchyAncestriesIDsCalls() []struct {
	Ctx        context.Context
	Attempt    int
	CodeListID string
	Codes      []string
} {
	var calls []struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}
	lockDBMockGetGenericHierarchyAncestriesIDs.RLock()
	calls = mock.calls.GetGenericHierarchyAncestriesIDs
	lockDBMockGetGenericHierarchyAncestriesIDs.RUnlock()
	return calls
}

// GetGenericHierarchyNodeIDs calls GetGenericHierarchyNodeIDsFunc.
func (mock *DBMock) GetGenericHierarchyNodeIDs(ctx context.Context, attempt int, codeListID string, codes []string) (map[string]string, error) {
	if mock.GetGenericHierarchyNodeIDsFunc == nil {
		panic("DBMock.GetGenericHierarchyNodeIDsFunc: method is nil but DB.GetGenericHierarchyNodeIDs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}{
		Ctx:        ctx,
		Attempt:    attempt,
		CodeListID: codeListID,
		Codes:      codes,
	}
	lockDBMockGetGenericHierarchyNodeIDs.Lock()
	mock.calls.GetGenericHierarchyNodeIDs = append(mock.calls.GetGenericHierarchyNodeIDs, callInfo)
	lockDBMockGetGenericHierarchyNodeIDs.Unlock()
	return mock.GetGenericHierarchyNodeIDsFunc(ctx, attempt, codeListID, codes)
}

// GetGenericHierarchyNodeIDsCalls gets all the calls that were made to GetGenericHierarchyNodeIDs.
// Check the length with:
//     len(mockedDB.GetGenericHierarchyNodeIDsCalls())
func (mock *DBMock) GetGenericHierarchyNodeIDsCalls() []struct {
	Ctx        context.Context
	Attempt    int
	CodeListID string
	Codes      []string
} {
	var calls []struct {
		Ctx        context.Context
		Attempt    int
		CodeListID string
		Codes      []string
	}
	lockDBMockGetGenericHierarchyNodeIDs.RLock()
	calls = mock.calls.GetGenericHierarchyNodeIDs
	lockDBMockGetGenericHierarchyNodeIDs.RUnlock()
	return calls
}

// GetHierarchyCodelist calls GetHierarchyCodelistFunc.
func (mock *DBMock) GetHierarchyCodelist(ctx context.Context, instanceID string, dimension string) (string, error) {
	if mock.GetHierarchyCodelistFunc == nil {
		panic("DBMock.GetHierarchyCodelistFunc: method is nil but DB.GetHierarchyCodelist was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	lockDBMockGetHierarchyCodelist.Lock()
	mock.calls.GetHierarchyCodelist = append(mock.calls.GetHierarchyCodelist, callInfo)
	lockDBMockGetHierarchyCodelist.Unlock()
	return mock.GetHierarchyCodelistFunc(ctx, instanceID, dimension)
}

// GetHierarchyCodelistCalls gets all the calls that were made to GetHierarchyCodelist.
// Check the length with:
//     len(mockedDB.GetHierarchyCodelistCalls())
func (mock *DBMock) GetHierarchyCodelistCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}
	lockDBMockGetHierarchyCodelist.RLock()
	calls = mock.calls.GetHierarchyCodelist
	lockDBMockGetHierarchyCodelist.RUnlock()
	return calls
}

// GetHierarchyElement calls GetHierarchyElementFunc.
func (mock *DBMock) GetHierarchyElement(ctx context.Context, instanceID string, dimension string, code string) (*models.HierarchyResponse, error) {
	if mock.GetHierarchyElementFunc == nil {
		panic("DBMock.GetHierarchyElementFunc: method is nil but DB.GetHierarchyElement was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
		Code       string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
		Code:       code,
	}
	lockDBMockGetHierarchyElement.Lock()
	mock.calls.GetHierarchyElement = append(mock.calls.GetHierarchyElement, callInfo)
	lockDBMockGetHierarchyElement.Unlock()
	return mock.GetHierarchyElementFunc(ctx, instanceID, dimension, code)
}

// GetHierarchyElementCalls gets all the calls that were made to GetHierarchyElement.
// Check the length with:
//     len(mockedDB.GetHierarchyElementCalls())
func (mock *DBMock) GetHierarchyElementCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
	Code       string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
		Code       string
	}
	lockDBMockGetHierarchyElement.RLock()
	calls = mock.calls.GetHierarchyElement
	lockDBMockGetHierarchyElement.RUnlock()
	return calls
}

// GetHierarchyNodeIDs calls GetHierarchyNodeIDsFunc.
func (mock *DBMock) GetHierarchyNodeIDs(ctx context.Context, attempt int, instanceID string, dimensionName string) (map[string]string, error) {
	if mock.GetHierarchyNodeIDsFunc == nil {
		panic("DBMock.GetHierarchyNodeIDsFunc: method is nil but DB.GetHierarchyNodeIDs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockGetHierarchyNodeIDs.Lock()
	mock.calls.GetHierarchyNodeIDs = append(mock.calls.GetHierarchyNodeIDs, callInfo)
	lockDBMockGetHierarchyNodeIDs.Unlock()
	return mock.GetHierarchyNodeIDsFunc(ctx, attempt, instanceID, dimensionName)
}

// GetHierarchyNodeIDsCalls gets all the calls that were made to GetHierarchyNodeIDs.
// Check the length with:
//     len(mockedDB.GetHierarchyNodeIDsCalls())
func (mock *DBMock) GetHierarchyNodeIDsCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockGetHierarchyNodeIDs.RLock()
	calls = mock.calls.GetHierarchyNodeIDs
	lockDBMockGetHierarchyNodeIDs.RUnlock()
	return calls
}

// GetHierarchyRoot calls GetHierarchyRootFunc.
func (mock *DBMock) GetHierarchyRoot(ctx context.Context, instanceID string, dimension string) (*models.HierarchyResponse, error) {
	if mock.GetHierarchyRootFunc == nil {
		panic("DBMock.GetHierarchyRootFunc: method is nil but DB.GetHierarchyRoot was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	lockDBMockGetHierarchyRoot.Lock()
	mock.calls.GetHierarchyRoot = append(mock.calls.GetHierarchyRoot, callInfo)
	lockDBMockGetHierarchyRoot.Unlock()
	return mock.GetHierarchyRootFunc(ctx, instanceID, dimension)
}

// GetHierarchyRootCalls gets all the calls that were made to GetHierarchyRoot.
// Check the length with:
//     len(mockedDB.GetHierarchyRootCalls())
func (mock *DBMock) GetHierarchyRootCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}
	lockDBMockGetHierarchyRoot.RLock()
	calls = mock.calls.GetHierarchyRoot
	lockDBMockGetHierarchyRoot.RUnlock()
	return calls
}

// HierarchyExists calls HierarchyExistsFunc.
func (mock *DBMock) HierarchyExists(ctx context.Context, instanceID string, dimension string) (bool, error) {
	if mock.HierarchyExistsFunc == nil {
		panic("DBMock.HierarchyExistsFunc: method is nil but DB.HierarchyExists was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	lockDBMockHierarchyExists.Lock()
	mock.calls.HierarchyExists = append(mock.calls.HierarchyExists, callInfo)
	lockDBMockHierarchyExists.Unlock()
	return mock.HierarchyExistsFunc(ctx, instanceID, dimension)
}

// HierarchyExistsCalls gets all the calls that were made to HierarchyExists.
// Check the length with:
//     len(mockedDB.HierarchyExistsCalls())
func (mock *DBMock) HierarchyExistsCalls() []struct {
	Ctx        context.Context
	InstanceID string
	Dimension  string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		Dimension  string
	}
	lockDBMockHierarchyExists.RLock()
	calls = mock.calls.HierarchyExists
	lockDBMockHierarchyExists.RUnlock()
	return calls
}

// MarkNodesToRemain calls MarkNodesToRemainFunc.
func (mock *DBMock) MarkNodesToRemain(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.MarkNodesToRemainFunc == nil {
		panic("DBMock.MarkNodesToRemainFunc: method is nil but DB.MarkNodesToRemain was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockMarkNodesToRemain.Lock()
	mock.calls.MarkNodesToRemain = append(mock.calls.MarkNodesToRemain, callInfo)
	lockDBMockMarkNodesToRemain.Unlock()
	return mock.MarkNodesToRemainFunc(ctx, attempt, instanceID, dimensionName)
}

// MarkNodesToRemainCalls gets all the calls that were made to MarkNodesToRemain.
// Check the length with:
//     len(mockedDB.MarkNodesToRemainCalls())
func (mock *DBMock) MarkNodesToRemainCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockMarkNodesToRemain.RLock()
	calls = mock.calls.MarkNodesToRemain
	lockDBMockMarkNodesToRemain.RUnlock()
	return calls
}

// RemoveCloneEdges calls RemoveCloneEdgesFunc.
func (mock *DBMock) RemoveCloneEdges(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.RemoveCloneEdgesFunc == nil {
		panic("DBMock.RemoveCloneEdgesFunc: method is nil but DB.RemoveCloneEdges was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockRemoveCloneEdges.Lock()
	mock.calls.RemoveCloneEdges = append(mock.calls.RemoveCloneEdges, callInfo)
	lockDBMockRemoveCloneEdges.Unlock()
	return mock.RemoveCloneEdgesFunc(ctx, attempt, instanceID, dimensionName)
}

// RemoveCloneEdgesCalls gets all the calls that were made to RemoveCloneEdges.
// Check the length with:
//     len(mockedDB.RemoveCloneEdgesCalls())
func (mock *DBMock) RemoveCloneEdgesCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockRemoveCloneEdges.RLock()
	calls = mock.calls.RemoveCloneEdges
	lockDBMockRemoveCloneEdges.RUnlock()
	return calls
}

// RemoveCloneEdgesFromSourceIDs calls RemoveCloneEdgesFromSourceIDsFunc.
func (mock *DBMock) RemoveCloneEdgesFromSourceIDs(ctx context.Context, attempt int, ids map[string]string) error {
	if mock.RemoveCloneEdgesFromSourceIDsFunc == nil {
		panic("DBMock.RemoveCloneEdgesFromSourceIDsFunc: method is nil but DB.RemoveCloneEdgesFromSourceIDs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]string
	}{
		Ctx:     ctx,
		Attempt: attempt,
		Ids:     ids,
	}
	lockDBMockRemoveCloneEdgesFromSourceIDs.Lock()
	mock.calls.RemoveCloneEdgesFromSourceIDs = append(mock.calls.RemoveCloneEdgesFromSourceIDs, callInfo)
	lockDBMockRemoveCloneEdgesFromSourceIDs.Unlock()
	return mock.RemoveCloneEdgesFromSourceIDsFunc(ctx, attempt, ids)
}

// RemoveCloneEdgesFromSourceIDsCalls gets all the calls that were made to RemoveCloneEdgesFromSourceIDs.
// Check the length with:
//     len(mockedDB.RemoveCloneEdgesFromSourceIDsCalls())
func (mock *DBMock) RemoveCloneEdgesFromSourceIDsCalls() []struct {
	Ctx     context.Context
	Attempt int
	Ids     map[string]string
} {
	var calls []struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]string
	}
	lockDBMockRemoveCloneEdgesFromSourceIDs.RLock()
	calls = mock.calls.RemoveCloneEdgesFromSourceIDs
	lockDBMockRemoveCloneEdgesFromSourceIDs.RUnlock()
	return calls
}

// RemoveNodesNotMarkedToRemain calls RemoveNodesNotMarkedToRemainFunc.
func (mock *DBMock) RemoveNodesNotMarkedToRemain(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.RemoveNodesNotMarkedToRemainFunc == nil {
		panic("DBMock.RemoveNodesNotMarkedToRemainFunc: method is nil but DB.RemoveNodesNotMarkedToRemain was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockRemoveNodesNotMarkedToRemain.Lock()
	mock.calls.RemoveNodesNotMarkedToRemain = append(mock.calls.RemoveNodesNotMarkedToRemain, callInfo)
	lockDBMockRemoveNodesNotMarkedToRemain.Unlock()
	return mock.RemoveNodesNotMarkedToRemainFunc(ctx, attempt, instanceID, dimensionName)
}

// RemoveNodesNotMarkedToRemainCalls gets all the calls that were made to RemoveNodesNotMarkedToRemain.
// Check the length with:
//     len(mockedDB.RemoveNodesNotMarkedToRemainCalls())
func (mock *DBMock) RemoveNodesNotMarkedToRemainCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockRemoveNodesNotMarkedToRemain.RLock()
	calls = mock.calls.RemoveNodesNotMarkedToRemain
	lockDBMockRemoveNodesNotMarkedToRemain.RUnlock()
	return calls
}

// RemoveRemainMarker calls RemoveRemainMarkerFunc.
func (mock *DBMock) RemoveRemainMarker(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.RemoveRemainMarkerFunc == nil {
		panic("DBMock.RemoveRemainMarkerFunc: method is nil but DB.RemoveRemainMarker was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockRemoveRemainMarker.Lock()
	mock.calls.RemoveRemainMarker = append(mock.calls.RemoveRemainMarker, callInfo)
	lockDBMockRemoveRemainMarker.Unlock()
	return mock.RemoveRemainMarkerFunc(ctx, attempt, instanceID, dimensionName)
}

// RemoveRemainMarkerCalls gets all the calls that were made to RemoveRemainMarker.
// Check the length with:
//     len(mockedDB.RemoveRemainMarkerCalls())
func (mock *DBMock) RemoveRemainMarkerCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockRemoveRemainMarker.RLock()
	calls = mock.calls.RemoveRemainMarker
	lockDBMockRemoveRemainMarker.RUnlock()
	return calls
}

// SetHasData calls SetHasDataFunc.
func (mock *DBMock) SetHasData(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.SetHasDataFunc == nil {
		panic("DBMock.SetHasDataFunc: method is nil but DB.SetHasData was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockSetHasData.Lock()
	mock.calls.SetHasData = append(mock.calls.SetHasData, callInfo)
	lockDBMockSetHasData.Unlock()
	return mock.SetHasDataFunc(ctx, attempt, instanceID, dimensionName)
}

// SetHasDataCalls gets all the calls that were made to SetHasData.
// Check the length with:
//     len(mockedDB.SetHasDataCalls())
func (mock *DBMock) SetHasDataCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockSetHasData.RLock()
	calls = mock.calls.SetHasData
	lockDBMockSetHasData.RUnlock()
	return calls
}

// SetNumberOfChildren calls SetNumberOfChildrenFunc.
func (mock *DBMock) SetNumberOfChildren(ctx context.Context, attempt int, instanceID string, dimensionName string) error {
	if mock.SetNumberOfChildrenFunc == nil {
		panic("DBMock.SetNumberOfChildrenFunc: method is nil but DB.SetNumberOfChildren was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}{
		Ctx:           ctx,
		Attempt:       attempt,
		InstanceID:    instanceID,
		DimensionName: dimensionName,
	}
	lockDBMockSetNumberOfChildren.Lock()
	mock.calls.SetNumberOfChildren = append(mock.calls.SetNumberOfChildren, callInfo)
	lockDBMockSetNumberOfChildren.Unlock()
	return mock.SetNumberOfChildrenFunc(ctx, attempt, instanceID, dimensionName)
}

// SetNumberOfChildrenCalls gets all the calls that were made to SetNumberOfChildren.
// Check the length with:
//     len(mockedDB.SetNumberOfChildrenCalls())
func (mock *DBMock) SetNumberOfChildrenCalls() []struct {
	Ctx           context.Context
	Attempt       int
	InstanceID    string
	DimensionName string
} {
	var calls []struct {
		Ctx           context.Context
		Attempt       int
		InstanceID    string
		DimensionName string
	}
	lockDBMockSetNumberOfChildren.RLock()
	calls = mock.calls.SetNumberOfChildren
	lockDBMockSetNumberOfChildren.RUnlock()
	return calls
}

// SetNumberOfChildrenFromIDs calls SetNumberOfChildrenFromIDsFunc.
func (mock *DBMock) SetNumberOfChildrenFromIDs(ctx context.Context, attempt int, ids map[string]string) error {
	if mock.SetNumberOfChildrenFromIDsFunc == nil {
		panic("DBMock.SetNumberOfChildrenFromIDsFunc: method is nil but DB.SetNumberOfChildrenFromIDs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]string
	}{
		Ctx:     ctx,
		Attempt: attempt,
		Ids:     ids,
	}
	lockDBMockSetNumberOfChildrenFromIDs.Lock()
	mock.calls.SetNumberOfChildrenFromIDs = append(mock.calls.SetNumberOfChildrenFromIDs, callInfo)
	lockDBMockSetNumberOfChildrenFromIDs.Unlock()
	return mock.SetNumberOfChildrenFromIDsFunc(ctx, attempt, ids)
}

// SetNumberOfChildrenFromIDsCalls gets all the calls that were made to SetNumberOfChildrenFromIDs.
// Check the length with:
//     len(mockedDB.SetNumberOfChildrenFromIDsCalls())
func (mock *DBMock) SetNumberOfChildrenFromIDsCalls() []struct {
	Ctx     context.Context
	Attempt int
	Ids     map[string]string
} {
	var calls []struct {
		Ctx     context.Context
		Attempt int
		Ids     map[string]string
	}
	lockDBMockSetNumberOfChildrenFromIDs.RLock()
	calls = mock.calls.SetNumberOfChildrenFromIDs
	lockDBMockSetNumberOfChildrenFromIDs.RUnlock()
	return calls
}
